package com.yahyaarhoune.transports.service.impl;

import com.yahyaarhoune.transports.dto.TrajetCreationRequestDTO;
import com.yahyaarhoune.transports.exception.ResourceNotFoundException;
import com.yahyaarhoune.transports.models.*; // Using wildcard for brevity
import com.yahyaarhoune.transports.repository.*; // Using wildcard
import com.yahyaarhoune.transports.service.TrajetService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class TrajetServiceImpl implements TrajetService {

    private final TrajetRepository trajetRepository;
    private final VehiculeRepository vehiculeRepository;
    private final ConducteurRepository conducteurRepository;
    private final UtilisateurStandardRepository utilisateurStandardRepository;
    private final IncidentRepository incidentRepository;
    private final TicketRepository ticketRepository; // Now definitely needed

    @Autowired
    public TrajetServiceImpl(TrajetRepository trajetRepository, VehiculeRepository vehiculeRepository,
                             ConducteurRepository conducteurRepository, UtilisateurStandardRepository utilisateurStandardRepository,
                             IncidentRepository incidentRepository, TicketRepository ticketRepository) {
        this.trajetRepository = trajetRepository;
        this.vehiculeRepository = vehiculeRepository;
        this.conducteurRepository = conducteurRepository;
        this.utilisateurStandardRepository = utilisateurStandardRepository;
        this.incidentRepository = incidentRepository;
        this.ticketRepository = ticketRepository;
    }

    @Override
    @Transactional
    public Trajet createTrajet(Trajet trajet) { // Matches interface: takes Trajet object
        // Validate Trajet object basic properties
        if (trajet.getOrigine() == null || trajet.getOrigine().isEmpty() ||
                trajet.getDestination() == null || trajet.getDestination().isEmpty() ||
                trajet.getHeureDepart() == null || trajet.getHeureArrivee() == null) {
            throw new IllegalArgumentException("Origine, destination, heure de départ et heure d'arrivée sont requis.");
        }

        if (trajet.getHeureArrivee().isBefore(trajet.getHeureDepart())) {
            throw new IllegalArgumentException("L'heure d'arrivée ne peut pas être avant l'heure de départ.");
        }

        // Ensure Vehicule and Conducteur are fetched and managed if only IDs are provided initially
        // (e.g., from a JSON request that was mapped to a Trajet object)
        if (trajet.getVehicule() != null && trajet.getVehicule().getId() != null) {
            Vehicule vehicule = vehiculeRepository.findById(trajet.getVehicule().getId())
                    .orElseThrow(() -> new ResourceNotFoundException("Vehicule", "id", trajet.getVehicule().getId()));
            trajet.setVehicule(vehicule);
        } else {
            throw new IllegalArgumentException("Un véhicule valide est requis pour créer un trajet.");
        }

        if (trajet.getConducteur() != null && trajet.getConducteur().getId() != null) {
            Conducteur conducteur = conducteurRepository.findById(Math.toIntExact(trajet.getConducteur().getId()))
                    .orElseThrow(() -> new ResourceNotFoundException("Conducteur", "id", trajet.getConducteur().getId()));
            trajet.setConducteur(conducteur);
        } else {
            throw new IllegalArgumentException("Un conducteur valide est requis pour créer un trajet.");
        }
        trajet.setId(null); // Ensure ID is generated by the database
        return trajetRepository.save(trajet);
    }

    @Override
    @Transactional(readOnly = true)
    public List<Trajet> getAllTrajets() {
        return trajetRepository.findAll();
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<Trajet> getTrajetById(Integer id) {
        return trajetRepository.findById(id);
    }

    @Override
    @Transactional
    public Optional<Trajet> updateTrajet(Integer id, Trajet trajetDetails) { // Matches interface: returns Optional<Trajet>
        return trajetRepository.findById(id)
                .map(existingTrajet -> {
                    existingTrajet.setOrigine(trajetDetails.getOrigine());
                    existingTrajet.setDestination(trajetDetails.getDestination());
                    existingTrajet.setHeureDepart(trajetDetails.getHeureDepart());
                    existingTrajet.setHeureArrivee(trajetDetails.getHeureArrivee());

                    if (trajetDetails.getHeureArrivee().isBefore(trajetDetails.getHeureDepart())) {
                        throw new IllegalArgumentException("L'heure d'arrivée ne peut pas être avant l'heure de départ pour la mise à jour.");
                    }

                    if (trajetDetails.getVehicule() != null && trajetDetails.getVehicule().getId() != null) {
                        Vehicule vehicule = vehiculeRepository.findById(trajetDetails.getVehicule().getId())
                                .orElseThrow(() -> new ResourceNotFoundException("Vehicule", "id", trajetDetails.getVehicule().getId()));
                        existingTrajet.setVehicule(vehicule);
                    } else if (trajetDetails.getVehicule() == null) { // Allow unassigning vehicle explicitly
                        existingTrajet.setVehicule(null);
                    }


                    if (trajetDetails.getConducteur() != null && trajetDetails.getConducteur().getId() != null) {
                        Conducteur conducteur = conducteurRepository.findById(Math.toIntExact(trajetDetails.getConducteur().getId()))
                                .orElseThrow(() -> new ResourceNotFoundException("Conducteur", "id", trajetDetails.getConducteur().getId()));
                        existingTrajet.setConducteur(conducteur);
                    } else if (trajetDetails.getConducteur() == null) { // Allow unassigning conductor explicitly
                        existingTrajet.setConducteur(null);
                    }
                    return trajetRepository.save(existingTrajet);
                });
    }

    @Override
    @Transactional
    public boolean deleteTrajet(Integer id) { // Matches interface: returns boolean
        Optional<Trajet> trajetOpt = trajetRepository.findById(id);
        if (trajetOpt.isPresent()) {
            Trajet trajet = trajetOpt.get();

            // Handle related entities before deleting Trajet
            // 1. Dissociate passengers (important for ManyToMany if Trajet is an owner or to clean join table)
            trajet.getListePassagers().forEach(utilisateur -> utilisateur.getHistoriqueTrajets().remove(trajet));
            // No need to save utilisateur here if Trajet is the owner of the @JoinTable or if cascade is well set.
            // If UtilisateurStandard is owner, then you would save each utilisateur or manage through UtilisateurStandardService.
            trajet.getListePassagers().clear(); // Clear on Trajet side

            // 2. Handle Tickets associated with this Trajet
            // Option: Delete them or mark them as cancelled/invalid
            List<Ticket> tickets = ticketRepository.findByTrajet(trajet);
            ticketRepository.deleteAll(tickets); // Example: Deleting all tickets for this trajet

            // 3. Handle Incidents associated with this Trajet
            // Option: Dissociate them (set trajet to null) or delete them
            List<Incident> incidents = incidentRepository.findByTrajet(trajet);
            for (Incident incident : incidents) {
                incident.setTrajet(null); // Dissociate
                incidentRepository.save(incident); // Save the change
            }
            // Or: incidentRepository.deleteAll(incidents); if that's the business rule

            trajetRepository.deleteById(id);
            return true;
        }
        return false; // Trajet not found
    }

    @Override
    @Transactional(readOnly = true)
    public List<UtilisateurStandard> getPassagersForTrajet(Integer trajetId) {
        Trajet trajet = trajetRepository.findById(trajetId)
                .orElseThrow(() -> new ResourceNotFoundException("Trajet", "id", trajetId));
        trajet.getListePassagers().size(); // Initialize if lazy
        return trajet.getListePassagers();
    }

    @Override
    @Transactional(readOnly = true)
    public List<Incident> getIncidentsForTrajet(Integer trajetId) {
        Trajet trajet = trajetRepository.findById(trajetId)
                .orElseThrow(() -> new ResourceNotFoundException("Trajet", "id", trajetId));
        // Assuming IncidentRepository has findByTrajet method
        return incidentRepository.findByTrajet(trajet);
    }

    @Override // Added to match the updated interface
    @Transactional(readOnly = true)
    public List<Ticket> getTicketsForTrajet(Integer trajetId) {
        Trajet trajet = trajetRepository.findById(trajetId)
                .orElseThrow(() -> new ResourceNotFoundException("Trajet", "id", trajetId));
        // Assuming TicketRepository has findByTrajet method
        return ticketRepository.findByTrajet(trajet);
    }

    @Override // Added to match the updated interface
    @Transactional
    public Trajet addPassagerToTrajet(Integer trajetId, Integer utilisateurId) {
        Trajet trajet = trajetRepository.findById(trajetId)
                .orElseThrow(() -> new ResourceNotFoundException("Trajet", "id", trajetId));
        UtilisateurStandard utilisateur = utilisateurStandardRepository.findById(utilisateurId)
                .orElseThrow(() -> new ResourceNotFoundException("UtilisateurStandard", "id", utilisateurId));

        // Manage bidirectional relationship for ManyToMany
        if (!trajet.getListePassagers().contains(utilisateur)) {
            trajet.getListePassagers().add(utilisateur);
        }
        if (!utilisateur.getHistoriqueTrajets().contains(trajet)) {
            utilisateur.getHistoriqueTrajets().add(trajet);
            // If UtilisateurStandard is the owner of the @JoinTable mapping (e.g., has `joinColumns`
            // and Trajet has `mappedBy`), then saving the utilisateur might be necessary.
            // If Trajet is the owner (has `joinColumns`), saving trajet is sufficient.
            // Given the UML, Trajet seems to be the owner of `listePassagers`.
        }
        return trajetRepository.save(trajet); // Saving the Trajet should update the join table
    }

    @Override // Added to match the updated interface
    @Transactional
    public Trajet removePassagerFromTrajet(Integer trajetId, Integer utilisateurId) {
        Trajet trajet = trajetRepository.findById(trajetId)
                .orElseThrow(() -> new ResourceNotFoundException("Trajet", "id", trajetId));
        UtilisateurStandard utilisateur = utilisateurStandardRepository.findById(utilisateurId)
                .orElseThrow(() -> new ResourceNotFoundException("UtilisateurStandard", "id", utilisateurId));

        boolean removedFromTrajet = trajet.getListePassagers().remove(utilisateur);
        boolean removedFromUtilisateur = utilisateur.getHistoriqueTrajets().remove(trajet);

        if (removedFromTrajet || removedFromUtilisateur) {
            // If changes were made, persist the owner of the relationship
            // Assuming Trajet is the owner for `listePassagers`.
            return trajetRepository.save(trajet);
            // If UtilisateurStandard was also an owner side of a different mapping, save it too.
            // utilisateurStandardRepository.save(utilisateur);
        }
        return trajet; // Return trajet even if no changes made, or throw if not found
    }


    @Override
    @Transactional
    public Trajet createTrajetFromDTO(TrajetCreationRequestDTO trajetDto) {
        // ... (validate times and IDs from DTO as shown in previous response) ...

        Vehicule vehicule = vehiculeRepository.findById(trajetDto.getVehiculeId())
                .orElseThrow(() -> new ResourceNotFoundException("Vehicule", "id", trajetDto.getVehiculeId()));
        Conducteur conducteur = conducteurRepository.findById(trajetDto.getConducteurId())
                .orElseThrow(() -> new ResourceNotFoundException("Conducteur", "id", trajetDto.getConducteurId()));

        Trajet trajet = new Trajet();
        trajet.setId(null);
        trajet.setOrigine(trajetDto.getOrigine());
        trajet.setDestination(trajetDto.getDestination());
        trajet.setHeureDepart(trajetDto.getHeureDepart());
        trajet.setHeureArrivee(trajetDto.getHeureArrivee());
        trajet.setVehicule(vehicule);
        trajet.setConducteur(conducteur);
        return trajetRepository.save(trajet);
    }
}